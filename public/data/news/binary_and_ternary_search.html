<b>Binary Search</b>
^br^
\(f(x)\) is a decreasing function, i.e. \(f(x) > f(x+1)\). We known want to find the smallest integer x such that \(f(x) <= v\), where \(v\) is a given integer.
^br^
Let's say that currently the smallest valid x we have found is a very large number (\(f(\infty) <= v \) always holds).
^br^
Now we are going to pick a sufficiently large power of 2 (e.g. (\(2^{64}+2^{64}-1 >= x\) should hold)).
^br^
First, let's test if \(f(x-2^{64}) <= v\). If yes, \(x := x-2^{64}\). If no, do noting.
^br^
Now, let's do the same procedure with \(f(x-2^{63})\) and so on until \(f(x-2^{0})\).
^br^
This allows us to find the \(x\) in \(O(log(n))\).
^br^
<b>Ternary Search</b>
^br^
Now suppose we have a function \(f(x)\) with exactly \(1\) global minimum and no local minima. This function first has a decreasing phase and then an increasing one.
^br^
We now want to find the value of the minimum of \(f(x)\).
^br^
Let's define \(ts(start, end)\) as a function that returns the minimum on the range \([start; end]\).
^br^
In ternary search, we will split the segment \([start; end]\) in three by defining $$mid0 = start+(end-start)/3$$ and $$mid1 = end-(end-start)/3$$
^br^
If \(start == end\), \(ts(start, end)\) should return \(f(start)\).
^br^
Otherwise, if \(f(mid0) <= f(mid1)\), \(return ts(start, mid1)\).
^br^
Otherwise, if \(f(mid1) <= f(mid0)\), \(return ts(mid0, end)\).
^br^
This solves the problem in \(O(log(n))\) time and \(O(1)\) memory, (\(x\) extra costs depending on calculating \(f(x)\) iself).
^br^
Note that this can be generalised to functions with global maxima and no global minima.